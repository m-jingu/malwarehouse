#!/usr/bin/env python
# -*- coding: utf-8 -*-
"""
malwarehouse.py

Created by Scott Roberts.
Copyright (c) 2012 TogaFoamParty Studios. All rights reserved.

Yara/Exiftool/SSdeep/VT added by Chris Clark chris@xenosec.org
"""

import datetime, os, hashlib, sqlite3, shutil, re, urllib, configparser, json
import magic
from optparse import OptionParser
from collections import OrderedDict

#Get Config Options
conffile = os.path.join(os.path.dirname(__file__), 'malwarehouse.cfg')
config = configparser.SafeConfigParser()
config.read(conffile)

option_base_dir = config.get('settings','basedir')

# Import optional requirments

if config.get('options', 'metadata') == 'On':
  import exiftool
if config.get('options', 'yara') == 'On':
  import yara
if config.get('options', 'ssdeep') == 'On':
  import pydeep 

def check_prelim():
  """Initial setup code. Eventually this will set options."""

  db_path = option_base_dir + "malwarehouse.db"
  dir_path = os.path.dirname(option_base_dir)
  
  if not os.path.exists(dir_path):
    print("Base directory", dir_path, "doesn't exist. Creating it...")
    os.makedirs(dir_path)

  if not os.path.exists(db_path):
    print("Database", db_path, "doesn't exist. Creating it...")
    
    conn = sqlite3.connect(db_path)
    c = conn.cursor()

    # Create table
    c.execute('''CREATE TABLE IF NOT EXISTS malwarehouse_index (datetime text, name text, mimetype text, tags text, size integer, md5 text, sha1 text, sha256 text primary key, source text, notes text, vtapi text, metadata text, ssdeep text, yara text)''')

    # Save (commit) the changes
    conn.commit()
  
    # We can also close the cursor if we are done with it
    c.close()

  return True

def vtapi(md5):
  url = "https://www.virustotal.com/vtapi/v2/file/report"
  parameters = {"resource": md5, "apikey": config.get('settings','vtapikey') }
  data = urllib.urlencode(parameters)
  req = urllib.request(url, data)
  response = urllib.request.urlopen(req)
  VTjson = json.loads(response.read())
  #print VTjson
  if VTjson['response_code'] == 1 :
    return str(VTjson['positives']) + '/' + str(VTjson['total']) + ' on ' + str(VTjson['scan_date'])
  else :
    return "File Does Not Exist in VirusTotal"
    
def yara_scan(malware_path):
  compiledRules = yara.compile(config.get('settings','yararules'))
  matches = compiledRules.match(malware_path)
  return str(matches)

def get_md5(malware_path):
  """Wrapper for the usual md5 call because it's so verbose."""
  
  return hashlib.md5(file(malware_path, 'r').read()).hexdigest()

def get_ssdeep(malware_path):
  return pydeep.hash_file(malware_path)

def get_sha1(malware_path):
  return hashlib.sha1(file(malware_path, 'r').read()).hexdigest()

def get_sha256(malware_path):
  """Wrapper for the usual sha256 call because it's so verbose."""
  
  return hashlib.sha256(file(malware_path, 'r').read()).hexdigest()

def get_mime_type(malware_path):
  """Using magic library to detect the mime type of a given file."""  
  try:
    mime = magic.Magic(mime=True)
    return mime.from_file(malware_path)
  except Exception:
    return "Unknown"

def get_metadata(malware_path):
  with exiftool.ExifTool() as et:
    metadata = et.get_metadata(malware_path)
  del metadata[u'SourceFile']
  del metadata[u'File:FilePermissions']
  del metadata[u'File:Directory']
  del metadata[u'ExifTool:ExifToolVersion']
  try:
    del metadata[u'File:MIMEType']
  except Exception as e:
    print("[WARNING] ", e)
  metadataString = '\n'
  for each in metadata.items():
    try:
      metadataString += '\t\t' + str(each[0]).split(':', 1)[-1] + ": " + str(each[1]) + "\n"
    except Exception as e:
      continue

  return metadataString

def summary(report_json):
  """Prints an easy to read summary of the malware."""
  
  return "-> %s (%s) Source: %s \n   VirusTotal: %s  Tags: %s \n   Notes: %s \n   Yara: %s \n   -> Sample Location: %s \n" % (report_json['name'], report_json['md5'], report_json['source'],  report_json['vtapi'], report_json['tags'], report_json['notes'], report_json['yara'], option_base_dir + report_json['sha256'])

def details(report_json):
  """Prints an easy to read summary of the malware."""
  
  details = ""
  details += "datetime:      %s\n" % (report_json['datetime'])
  details += "name:          %s\n" % (report_json['name'])
  details += "source:        %s\n" % (report_json['source'])
  details += "tags:          %s\n" % (report_json['tags'])
  details += "notes:         %s\n" % (report_json['notes'])
  details += "mimetype:      %s\n" % (report_json['mimetype'])
  details += "size:          %s\n" % (report_json['size'])
  details += "md5:           %s\n" % (report_json['md5'])
  details += "sha1:          %s\n" % (report_json['sha1'])
  details += "sha256:        %s\n" % (report_json['sha256'])
  details += "ssdeep:        %s\n" % (report_json['ssdeep'])
  details += "virustotal:    %s\n" % (report_json['vtapi'])
  details += "yara:          %s\n" % (report_json['yara']) 
  details += "metadata:      %s\n" % (report_json['metadata']) 
  details += "\n"
  details += "sample directory: %s" % option_base_dir + report_json['sha256']

  return details

def load_db(report_json):
  """Load information about the sample into the index DB."""

  conn = sqlite3.connect(option_base_dir + "malwarehouse.db")
  c = conn.cursor()

  # Insert a row of data 
  try:
    c.execute("INSERT INTO malwarehouse_index VALUES (\"%s\", \"%s\", \"%s\", \"%s\", \"%d\", \"%s\", \"%s\", \"%s\", \"%s\", \"%s\", \"%s\", \"%s\", \"%s\", \"%s\")" % (report_json['datetime'], report_json['name'], report_json['mimetype'], report_json['tags'], report_json['size'], report_json['md5'], report_json['sha1'], report_json['sha256'], report_json['source'], report_json['notes'], report_json['vtapi'], report_json['metadata'], report_json['ssdeep'],  report_json['yara'],)) 

  except sqlite3.IntegrityError as e:
    c.close()
    print("[ERROR]", e)
    print("sha256", report_json['sha256'], "already exists. If you want to update information of a sample, use option '-u'.")
    return False
  
  # Save (commit) the changes
  conn.commit()
  
  # We can also close the cursor if we are done with it
  c.close()

  print("Sample", report_json['name'], "loaded...")
  return True

def load_directory(report_json, malware_path):
  """Creates a directory to store the malware and summary."""
  print("Loading Malware", malware_path)

  sample_dir = "%s%s" % (option_base_dir, report_json['sha256'])

  if not os.path.exists(sample_dir):
    print("Creating", sample_dir)
    os.makedirs(sample_dir)

  #shutil.move(malware_path, sample_dir)
  shutil.copy(malware_path, sample_dir)

  with open(sample_dir + '/summary.txt', 'w') as text_file:
    text_file.write(details(report_json))

  return True

def malware_loader(report_json, malware_path):
    if load_db(report_json):
        load_directory(report_json, malware_path)
    else:
        print("Load DB failed.")

def parse_sqlite_result(unparsed):
    "Takes the results from a SQLite query and parses it as a dictionary."

    return {'datetime': unparsed[0], 'name': unparsed[1], 'mimetype': unparsed[2], 'tags': unparsed[3], 'size': unparsed[4], 'md5': unparsed[5], 'sha1': unparsed[6], 'sha256': unparsed[7], 'source': unparsed[8], 'notes': unparsed[9], 'vtapi': unparsed[10], 'metadata': unparsed[11], 'ssdeep': unparsed[12], 'yara': unparsed[13]}

def find_sample(find_string):
    
    conn = sqlite3.connect(option_base_dir + "malwarehouse.db")
    c = conn.cursor()

    c.execute("SELECT * FROM malwarehouse_index WHERE sha256 LIKE :hash OR md5 LIKE :hash OR sha1 LIKE :hash OR name LIKE :query OR tags LIKE :query OR source LIKE :query OR notes LIKE :query", {"hash" : find_string, "query" : '%' + find_string + '%'})

    data=c.fetchall()
    
    if data:
        print("\nResults for \"", find_string, "\":\n")
        for result in data:
            print(summary(parse_sqlite_result(result)))
        return True
    else:
        print("No Samples Named, Hashed, Sourced, Noted or Tagged:", find_string)
        return False

def find_sample_meta(find_string):
    
    conn = sqlite3.connect(option_base_dir + "malwarehouse.db")
    c = conn.cursor()
    
    c.execute("SELECT * FROM malwarehouse_index WHERE metadata LIKE :query", {"query" : '%' + find_string + '%'})

    data=c.fetchall()
    
    if data:
        print("\nResults for \"" + find_string + "\" in Metadata:\n")
        for result in data:
            print(summary(parse_sqlite_result(result)))
        return True
    else:
        print("No Samples have Metadata matches for:", find_string)
        return False

def find_sample_yara(find_string):
    
    conn = sqlite3.connect(option_base_dir + "malwarehouse.db")
    c = conn.cursor()
    
    c.execute("SELECT * FROM malwarehouse_index WHERE yara LIKE :query", {"query" : '%' + find_string + '%'})

    data=c.fetchall()

    if data:
        print("\nResults for \"" + find_string + "\" in Yara Matches:\n")
        for result in data:
            print(summary(parse_sqlite_result(result)))
        return True
    else:
        print("No Samples have yara matches for:", find_string)
        return False

def recent(quantity='5'):
    """Returns a summary of the last n (default: n = 5) pieces of malware."""
    conn = sqlite3.connect(option_base_dir + "malwarehouse.db")
    c = conn.cursor()

    try:
        float(quantity)
    except:
        raise ValueError

    c.execute("SELECT DISTINCT * FROM malwarehouse_index ORDER BY datetime DESC LIMIT %s;" % quantity)  
    data = c.fetchall()

    print("\n%s Most Recent Samples:", quantity)
    for result in data:
        print(summary(parse_sqlite_result(result)))
        
    return True

def basic_analyzer(malware_path, source, tags, notes):
    """Basic analyzer does the initial triage analysis getting size & hashes along with user supplied data. Returns a dictionary with info."""

    try:
        with open(malware_path) as f: pass
    except IOError as e:
        print("You specified an invalid malware target path.")
        exit(0)
        return False
    
    malware_definition = {}

    #Parsing Custom Options    
    malware_definition["source"] = source
    malware_definition["tags"] = tags
    malware_definition["notes"] = notes

    #Parsing Automatically Generated Options
    malware_definition["name"] = malware_path.split('/')[-1]
    malware_definition["datetime"] = str(datetime.datetime.now())
    malware_definition["size"] = os.stat(malware_path).st_size
    malware_definition["md5"] = get_md5(malware_path)
    malware_definition["ssdeep"] = get_ssdeep(malware_path) if config.get('options', 'ssdeep') == 'On' else 'Disabled'
    malware_definition["yara"] = yara_scan(malware_path) if config.get('options', 'yara') == 'On' else 'Disabled'
    malware_definition["sha1"] = get_sha1(malware_path) 
    malware_definition["sha256"] = get_sha256(malware_path) 
    malware_definition["mimetype"] = get_mime_type(malware_path) 
    malware_definition["vtapi"] = vtapi(malware_definition["md5"]) if config.get('options', 'vtcheck') == 'On' else 'Disabled'
    malware_definition["metadata"] = get_metadata(malware_path) if config.get('options', 'metadata') == 'On' else 'Disabled'

    return malware_definition

def update_info(sha256, source, tags, notes):
    """Update information about the sample into the index DB."""

    setvalue = ''
    if source is not None:
        setvalue += "source = '%s' " % source
    if tags != 'No tags':
        setvalue += "tags = '%s' " % tags
    if notes != '':
        setvalue += "notes = '%s' " % notes
    setvalue = setvalue.replace("' tags", "', tags").replace("' notes", "', notes")

    if setvalue == '':
        print("[ERROR] Value not specified. \nSet information about the sample. source, tags or notes.")
        return False

    conn = sqlite3.connect(option_base_dir + "malwarehouse.db")
    c = conn.cursor()
  
    c.execute("SELECT count(*) from malwarehouse_index WHERE sha256 = '%s'" % sha256)
    if c.fetchone()[0] == 0:
        c.close()
        print("[ERROR] sha256", sha256, "not exists.")
        return False

    # Insert a row of data 
    c.execute("UPDATE malwarehouse_index SET %s WHERE sha256 = '%s'" % (setvalue, sha256))
    # Save (commit) the changes
    conn.commit()
    # We can also close the cursor if we are done with it
    c.close()
  
    print("Information of", sha256, "updated...")
    return True

def delete_sample(sha256):
    """Delete sample from index DB."""

    conn = sqlite3.connect(option_base_dir + "malwarehouse.db")
    c = conn.cursor()

    # Delete a row of data 
    c.execute("DELETE FROM malwarehouse_index WHERE sha256 = '%s'" % sha256)
    # Save (commit) the changes
    conn.commit()
    # We can also close the cursor if we are done with it
    c.close()
  
    print("The sample", sha256, "deleted...")
    return True

def delete_directory(sha256):
  """Delete a directory from store."""
  print("Deleting Malware", sha256)

  sample_dir = "%s%s" % (option_base_dir, sha256)

  if os.path.exists(sample_dir):
    print("Deleting", sample_dir)
    shutil.rmtree(sample_dir)

  return True

def main():
    if not check_prelim():
      print("[ERROR] Initial setup unable to complete. Exiting...")
      return False

    parser = OptionParser(usage="usage: %prog [options] filepath", version="%prog 0.1")
    parser.add_option("-s", "--source",
                      action="store",
                      type="string",
                      dest="SOURCE",
                      default=None,
                      help="Source of file")
    parser.add_option("-t", "--tags",
                      action="store",
                      type="string",
                      dest="TAGS",
                      default="No tags",
                      help="Any characteristics of the malware")
    parser.add_option("-n", "--notes",
                      action="store",
                      type="string",
                      dest="NOTES",
                      default="",
                      help="Notes about file")
    parser.add_option("-f", "--find",
                      action="store",
                      type="string",
                      dest="FIND",
                      default="",
                      help="Find a sample by name, tags, source, notes, md5, sha1, or sha256")
    parser.add_option("-m", "--metadata",
                      action="store",
                      type="string",
                      dest="MFIND",
                      default="",
                      help="Find a sample by searching Extracted Metadata")
    parser.add_option("-y", "--yara",
                      action="store",
                      type="string",
                      dest="YFIND",
                      default="",
                      help="Find a sample by searching Yara Matches")
    parser.add_option("-r", "--recent",
                      action="store",
                      type="string",
                      dest="QUANTITY",
                      default="",
                      help="Find the most recent # samples")
    parser.add_option("-u", "--update",
                      action="store",
                      type="string",
                      dest="UPDATE",
                      metavar="HASH",
                      default="",
                      help="Update data of a sample (sha256)")
    parser.add_option("-d", "--delete",
                      action="store",
                      type="string",
                      dest="DELETE",
                      metavar="HASH",
                      default="",
                      help="Delete data of a sample (sha256)")
    
    (options, args) = parser.parse_args()

    if options.QUANTITY:
        if recent(options.QUANTITY):
            return True
        else:
            return False
    elif options.FIND:
        if find_sample(options.FIND):
            return True
        else:
            return False
    elif options.MFIND:
        if find_sample_meta(options.MFIND):
            return True
        else:
            return False
    elif options.YFIND:
        if find_sample_yara(options.YFIND):
            return True
        else:
            return False
    elif options.UPDATE:
        if update_info(options.UPDATE, options.SOURCE, options.TAGS, options.NOTES):
            return True
        else:
            return False
    elif options.DELETE:
        if delete_sample(options.DELETE):
            delete_directory(options.DELETE)
            return True
        else:
            return False
    elif len(args) != 1 and not options.FIND and not options.MFIND and not options.YFIND and not options.UPDATE and not options.DELETE:
        parser.error("You didn't specify a malware target path.")
        return False
    else:
        #Parse malware file path and name
        malware_path = args[0]

        malware_definition = basic_analyzer(malware_path, options.SOURCE, options.TAGS, options.NOTES)

        print("Analysis complete. Loading.")
        malware_loader(malware_definition, malware_path)

    return True

if __name__ == "__main__":
    try:
        main()
    except KeyboardInterrupt:
        print("User aborted.")
    except SystemExit:
        pass
    #except:
        #SystemExit

